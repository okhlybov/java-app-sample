plugins {
    id 'buildlogic.javafx-common-conventions'
    id 'org.beryx.jlink'
    id 'com.google.osdetector'
}

dependencies {
    implementation project(':app-cli')
    implementation project(':app-javafx')
}

jlink {
    options = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']
    customImage {
        appModules = ['app.cli', 'app.javafx'] // Have to set this explicitly due to https://github.com/beryx/badass-jlink-plugin/issues/290
    }
    launcher {
        name = 'app'
        noConsole = false // For CLI app
        mainClass = 'app.cli.Main'
        moduleName = 'app.cli'
    }
    secondaryLauncher {
        name = 'appfx'
        noConsole = true // For GUI app
        winConsole = false // Override jpackage's --win-console behavior for a GUI app
        mainClass = 'app.javafx.Main'
        moduleName = 'app.javafx'
        jvmArgs = ['-Xmx256m']
    }
    jpackage {
        if(org.gradle.internal.os.OperatingSystem.current().windows) {
            imageOptions = ['--win-console'] // Set default console option for primary launcher, which is a console app on Windows
            installerType = 'msi'
            installerOptions = ['--type', 'msi', '--app-version', project.version, '--win-menu']
        }
    }
}

// Workaround for stray files slipping into the image
// This was supposed to be fixed in the org.beryx.jlink plugin, yet it seems to persist
// See https://github.com/beryx/badass-jlink-plugin/issues/51

task releaseWinX64(type: Exec) {
    dependsOn 'prepareRelease'
    dependsOn 'jpackageImage'
    commandLine 'cmd.exe', '/c', 'iscc.cmd', "${osdetector.arch}.iss", "/DMyAppVersion=${version}"
}

task releaseAppImage(type: Exec) {
    dependsOn 'prepareRelease'
    dependsOn 'jpackageImage'
    dependsOn 'copyAppImageFiles'
    commandLine 'sh', 'appimagetool.sh', 'build/jpackage/app', "build/release/app-${osdetector.os}.${osdetector.arch}-${version}.AppImage"
}

task copyAppImageFiles(type: Copy) {
    dependsOn 'jpackageImage'
    from 'appimage'; into 'build/jpackage/app'
}

task release {
    switch("${osdetector.os}.${osdetector.arch}") {
        case 'windows.x86_64':
            dependsOn 'releaseWinX64'
            break
        case 'linux.x86_64':
            dependsOn 'releaseAppImage'
            break
    }
}

tasks.named('jlink') {
    doLast {
        // Get rid of the buggy jlink -injected thrash
        project.delete 'build/image/app'
    }
}

tasks.named('jpackageImage') {
    doLast {
        // Get rid of the buggy jpackage -injected thrash
        def roots = [linux: 'build/jpackage/app/lib/app', windows: 'build/jpackage/app/runtime/app']
        project.delete fileTree(roots[osdetector.os]).matching {
            exclude '*.xml'
            exclude '*.cfg'
        }
    }
}

task createDirs {
    mustRunAfter 'clean'
    doLast {
        project.mkdir 'build/release'
    }
}

task prepareRelease {
    dependsOn 'createDirs'
    dependsOn 'createReadme'
    dependsOn 'copyLicense'
}

import org.apache.tools.ant.filters.*

task createReadme(type: Copy) {
    from 'README.in'
    into 'build/jpackage/app'
    rename {'README'}
    filter(ReplaceTokens, tokens: [VERSION: project.version.toString()])
}

task copyLicense(type: Copy) {
    from '../LICENSE'; into 'build/jpackage/app'
}